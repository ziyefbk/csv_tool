# 索引持久化功能实施计划

## 📋 功能概述

实现CSV文件行索引的持久化存储，将索引保存到 `.csv.idx` 文件，下次打开相同文件时直接加载索引，避免重复构建。

## 🎯 目标

- ✅ 索引保存到 `.csv.idx` 文件
- ✅ 文件打开时检查并加载索引（如果存在且有效）
- ✅ 索引有效性验证（文件修改时间、大小等）
- ✅ 索引失效时自动重新构建
- ✅ 索引文件格式版本控制

## 📊 实施计划

### Phase 1: 索引序列化/反序列化 ✅

**目标**: 实现索引的保存和加载

**任务清单**:
- [x] 确保 `RowIndex` 已实现 `Serialize` 和 `Deserialize`
- [ ] 实现 `save_index()` 方法
- [ ] 实现 `load_index()` 方法
- [ ] 添加索引文件路径生成函数
- [ ] 单元测试

**技术细节**:
- 使用 `bincode` 进行二进制序列化（更高效）
- 索引文件格式：`<csv_file>.csv.idx`
- 序列化格式：`bincode::serialize_into()`

### Phase 2: 索引元数据 ✅

**目标**: 添加索引元数据，用于验证索引有效性

**任务清单**:
- [ ] 定义索引元数据结构 `IndexMetadata`
- [ ] 元数据包含：
  - CSV文件路径
  - CSV文件大小
  - CSV文件修改时间
  - 索引版本号
  - 索引构建时间
- [ ] 序列化时包含元数据
- [ ] 反序列化时验证元数据

**元数据结构**:
```rust
#[derive(Serialize, Deserialize)]
pub struct IndexMetadata {
    csv_path: PathBuf,
    csv_size: u64,
    csv_mtime: SystemTime,  // 文件修改时间
    index_version: u32,     // 索引格式版本
    build_time: SystemTime, // 索引构建时间
    granularity: usize,     // 索引粒度
}
```

### Phase 3: 索引有效性验证 ✅

**目标**: 验证索引是否仍然有效

**任务清单**:
- [ ] 实现 `is_index_valid()` 方法
- [ ] 检查CSV文件是否存在
- [ ] 检查文件大小是否匹配
- [ ] 检查文件修改时间是否匹配
- [ ] 检查索引版本是否兼容
- [ ] 处理文件系统错误

**验证逻辑**:
```rust
fn is_index_valid(csv_path: &Path, metadata: &IndexMetadata) -> bool {
    // 1. 检查文件是否存在
    // 2. 检查文件大小
    // 3. 检查修改时间
    // 4. 检查版本兼容性
}
```

### Phase 4: 集成到CsvReader ✅

**目标**: 在 `CsvReader::open()` 中集成索引加载逻辑

**任务清单**:
- [ ] 修改 `CsvReader::open()` 方法
- [ ] 尝试加载索引
- [ ] 如果索引有效，使用加载的索引
- [ ] 如果索引无效或不存在，构建新索引并保存
- [ ] 添加配置选项（是否启用索引持久化）

**集成逻辑**:
```rust
pub fn open(...) -> Result<Self> {
    // 1. 检查索引文件是否存在
    // 2. 如果存在，尝试加载
    // 3. 验证索引有效性
    // 4. 如果有效，使用加载的索引
    // 5. 如果无效，构建新索引并保存
}
```

### Phase 5: 错误处理 ✅

**目标**: 完善的错误处理

**任务清单**:
- [ ] 添加索引相关错误类型
- [ ] 处理文件IO错误
- [ ] 处理序列化/反序列化错误
- [ ] 处理索引版本不兼容
- [ ] 优雅降级（索引加载失败时仍可正常工作）

### Phase 6: 测试 ✅

**目标**: 完整的测试覆盖

**任务清单**:
- [ ] 单元测试：索引保存和加载
- [ ] 单元测试：索引有效性验证
- [ ] 集成测试：完整流程测试
- [ ] 测试：索引失效场景
- [ ] 测试：文件修改后索引失效
- [ ] 性能测试：索引加载速度

## 🔧 技术实现细节

### 索引文件格式

**文件结构**:
```
[元数据长度: u64]
[元数据: IndexMetadata (bincode序列化)]
[索引数据: RowIndex (bincode序列化)]
```

**版本控制**:
- 当前版本：`1`
- 版本不兼容时，自动重建索引

### 文件路径

**索引文件路径规则**:
- CSV文件：`data.csv`
- 索引文件：`data.csv.idx`
- 位置：与CSV文件同一目录

### 性能考虑

- **保存时机**: 索引构建完成后立即保存
- **加载时机**: 文件打开时
- **异步保存**: 可选，使用 `tokio::spawn_blocking`（未来优化）

## 📝 API设计

### 新增方法

```rust
impl RowIndex {
    /// 保存索引到文件
    pub fn save_to_file(&self, csv_path: &Path, metadata: &IndexMetadata) -> Result<()>
    
    /// 从文件加载索引
    pub fn load_from_file(index_path: &Path) -> Result<(Self, IndexMetadata)>
}

impl CsvReader {
    /// 打开CSV文件（支持索引持久化）
    pub fn open<P>(path: P, has_headers: bool, delimiter: u8, index_granularity: usize) -> Result<Self>
    
    /// 打开CSV文件（禁用索引持久化）
    pub fn open_without_persistence<P>(...) -> Result<Self>
}
```

### 配置选项

```rust
pub struct CsvReaderOptions {
    pub has_headers: bool,
    pub delimiter: u8,
    pub index_granularity: usize,
    pub enable_index_persistence: bool,  // 新增
}
```

## 🧪 测试计划

### 单元测试

1. **索引保存测试**
   - 保存索引到文件
   - 验证文件存在
   - 验证文件内容正确

2. **索引加载测试**
   - 加载已保存的索引
   - 验证索引数据正确
   - 验证元数据正确

3. **有效性验证测试**
   - 文件未修改：索引有效
   - 文件大小变化：索引失效
   - 文件修改时间变化：索引失效

### 集成测试

1. **完整流程测试**
   - 打开文件 → 构建索引 → 保存索引
   - 再次打开 → 加载索引 → 验证正确性

2. **索引失效测试**
   - 修改CSV文件
   - 重新打开文件
   - 验证索引被重建

3. **性能测试**
   - 对比索引加载 vs 重新构建的时间
   - 验证性能提升

## 📊 预期收益

### 性能提升

| 场景 | 当前 | 优化后 | 提升 |
|------|------|--------|------|
| 首次打开1GB文件 | ~2秒 | ~2秒 | - |
| 再次打开（有索引） | ~2秒 | <100ms | **20x** |
| 索引文件大小 | - | ~几MB | - |

### 用户体验

- ✅ 重复打开同一文件速度显著提升
- ✅ 减少等待时间
- ✅ 提升使用体验

## 🚀 实施时间表

- **Phase 1**: 1天（索引序列化）
- **Phase 2**: 0.5天（元数据）
- **Phase 3**: 0.5天（有效性验证）
- **Phase 4**: 1天（集成）
- **Phase 5**: 0.5天（错误处理）
- **Phase 6**: 1天（测试）

**总计**: 约4-5天

## 📝 注意事项

1. **文件系统权限**: 确保有写入权限
2. **并发访问**: 多个进程同时访问时的处理
3. **索引文件清理**: 可选的自动清理机制
4. **跨平台兼容**: Windows/Linux/macOS路径处理
5. **错误恢复**: 索引文件损坏时的处理

## 🔄 未来优化

1. **异步保存**: 后台保存索引，不阻塞
2. **索引压缩**: 压缩索引文件大小
3. **增量索引**: 只更新变化的部分
4. **索引缓存**: 内存中缓存最近使用的索引

---

*创建时间: 2024*  
*最后更新: 2024*

